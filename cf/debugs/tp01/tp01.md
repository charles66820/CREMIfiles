# tp01

## Exo1

1. Done.
2. Done.
3. Done.
4. Done. (value `-val`)
5. Done. (WP goal `-wp`)
6.
   * Oui car on as pas préciser la specification donc il l'a determiner au pif.
   * Une division par 0 pour `div`, un overflow pour `add` et un overflow quant on change le signe d'un MIN_INT pour `aps`.
   * Il y a un overflow quant on addition MAX_INT et 42 (un nombre positif).
   * Il y a un overflow quant on change le signe d'un MIN_INT car en binaire le bit le plus a gauche est utiliser pour les nombre négatif donc il est plus grand que le MAX_INT.
   * Une division par 0.

7. Done. (wp-rte guards `-rte`)
8. Done.
9. Done. [v24.0](https://www.frama-c.com/fc-versions/chromium.html)

## Exo2

`/*@ ... */` ou `//@ ...` défini un contrat de fonction en ACSL.
`ensures <prop>;` permet de définir des propositions qui doivent être valide pour la fonction.
Ex de prop : (`\result <cond>`)

1. Done.

    ```c
    /*@
      ensures \result == a || \result == b;
      ensures \result >= a;
      ensures \result >= b;
    */
    ```

2. Done.

## Exo3

`requires <cond>` permet de définir des préconditions. Les préconditions sont des propriétés que l'on suppose vraie à l’entrée de la fonction. Ex :`requires a + b >= 3;`.

1. Done.
2. Done.

    ```diff
    /*@
    + requires a >= -1;
      ensures \result >= 0;
    */
    ```

3. Done.
4. Done.

    ```diff
    /*@
      requires a >= -1;
    + requires a < INT_MAX;
      ensures \result >= 0;
    */
    ```

5. Done.

    ```diff
    /*@
    + requires b != 0;
    + requires a / b <= INT_MAX;
      ensures \result == a/b;
    */
    ```

6. Done.

## Exo 4

1. Done.

   ```c
   /*@
     requires a * x >= INT_MIN;
     requires a * x <= INT_MAX;
     requires (a * x) + b >= INT_MIN;
     requires (a * x) + b <= INT_MAX;
     ensures \result == a * x + b;
   */
   ```

## Exo 5

`predicate <name>([<type> <argName>, ...]) = <cond>;` permet de définir des predicates.
Les predicates fonctionne comme une macro logique.
Ex : `predicate inInterval(integer a, integer b, integer c) = a >= b && a <= c;`.

`<expectCond> ==> <cond>` défini unie condition. Il vos mieux utiliser des `behavior`.

`behavior <name>:` permet de définir des comportements. ils permettent de spécifier des contrats de fonctions sur certaines plages de données.
`assumes <expectCond>;` c'est la condition d'un behavior.

`disjoint behaviors [<name>, ...];` est vraie si les domaines comportements sont disjoints.
`complete behaviors [<name>, ...];` est vraie si les comportements couvrent tous les cas possibles des données.

1. Done.

   ```c
    /*@
      ensures \result >= 0 || \result <= 3;
      ensures a==b || b==c || a==c ==> \result == 0; // \result == 0 when a==b || b==c || a==c
      ensures a < b < c || a < c < b ==> \result == 1; // \result == 1 when a < b&&c
      ensures b < a < c || b < c < a ==> \result == 2; // \result == 2 when b < a&&c
      ensures c < a < b || c < b < a ==> \result == 3; // \result == 3 when c < a&&b
    */
   ```

2. Done.

   ```diff
   +/*@
   +   predicate smallerThen(integer a, integer b, integer c) = a < b < c || a < c < b; // a < b&&c
   + */

    /*@
      ensures \result >= 0 || \result <= 3;
      ensures a==b || b==c || a==c ==> \result == 0; // \result == 0 when a==b || b==c || a==c
   -   ensures a < b < c || a < c < b ==> \result == 1;
   -   ensures b < a < c || b < c < a ==> \result == 2;
   -   ensures c < a < b || c < b < a ==> \result == 3;
   +   ensures smallerThen(a, b, c) ==> \result == 1; // \result == 1 when a < b&&c
   +   ensures smallerThen(b, a, c) ==> \result == 2; // \result == 2 when b < a&&c
   +   ensures smallerThen(c, a, b) ==> \result == 3; // \result == 3 when c < a&&b
   */
   ```

3. Done.

   ```diff
   /*@
      predicate smallerThen(integer a, integer b, integer c) = a < b < c || a < c < b; // a < b&&c
    */

    /*@
      ensures \result >= 0 || \result <= 3;
   -   ensures a==b || b==c || a==c ==> \result == 0;
   +   behavior twoEq:
   +     assumes a==b || b==c || a==c; // when a==b || b==c || a==c
   +     ensures \result == 0;
   -   ensures smallerThen(a, b, c) ==> \result == 1;
   +   behavior smallA:
   +     assumes smallerThen(a, b, c); // when a < b&&c
   +     ensures \result == 1;
   -   ensures smallerThen(b, a, c) ==> \result == 2;
   +   behavior smallB:
   +     assumes smallerThen(b, a, c); // when b < a&&c
   +     ensures \result == 2;
   -   ensures smallerThen(c, a, b) ==> \result == 3;
   +   behavior smallC:
   +     assumes smallerThen(c, a, b); // when c < a&&b
   +     ensures \result == 3;
   +   complete behaviors;
   +   disjoint behaviors twoEq,smallA,smallB,smallC;
   */

   ```

## Exo 6

1. TODO:
