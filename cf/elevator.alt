const nbFloors = 4;
node Door
  state isClose : bool : public;
  init isClose := true;
  event open, close;
  trans
    true |- open -> isClose := false;
    true |- close -> isClose := true;
edon

node Button
  state lightOn : bool : public;
  init lightOn := false;
  event
    push : public;
    off;
  trans
    true |- push -> lightOn := true;
    true |- off -> lightOn := false;
edon

node Floor
  sub
    B : Button;
    D : Door;
  event close, open;
  trans
    ~D.isClose |- close ->;
    D.isClose |- open ->;
  sync
    <close, B.off, D.close>;
    <open, D.open>;
edon

node Lift
  sub
    B : Button[nbFloors];
    D : Door;
  state level : [0, nbFloors-1] : public;
  init level := 0;
  event close[nbFloors], open, down, up;
  trans
    ~D.isClose & level=0 |- close[0] ->;
    ~D.isClose & level=1 |- close[1] ->;
    ~D.isClose & level=2 |- close[2] ->;
    ~D.isClose & level=3 |- close[3] ->;
    D.isClose |- open ->;
    D.isClose |- down -> level := level - 1;
    D.isClose |- up -> level := level + 1;
  sync
    <close[0], D.close, B[0].off>;
    <close[1], D.close, B[1].off>;
    <close[2], D.close, B[2].off>;
    <close[3], D.close, B[3].off>;
    <open, D.open>;
edon

node BuildingV0
  sub
    F : Floor[nbFloors];
    L : Lift;
  flow
    request : bool[nbFloors];
    requestDown, requestUp : bool;
  assert
    request[0] = (F[0].B.lightOn | L.B[0].lightOn);
    request[1] = (F[1].B.lightOn | L.B[1].lightOn);
    request[2] = (F[2].B.lightOn | L.B[2].lightOn);
    request[3] = (F[3].B.lightOn | L.B[3].lightOn);
    requestDown = (
      (request[0] & L.level > 0)
      | (request[1] & L.level > 1)
      | (request[2] & L.level > 2)
    );
    requestUp = (
      (request[3] & L.level < 3)
      | (request[2] & L.level < 2)
      | (request[1] & L.level < 1)
    );
  event open[nbFloors], down, up;
  trans
    L.level=0 & request[0] |- open[0] ->;
    L.level=1 & request[1] |- open[1] ->;
    L.level=2 & request[2] |- open[2] ->;
    L.level=3 & request[3] |- open[3] ->;
    requestDown |- down ->;
    requestUp |- up ->;
  sync
    <F[0].close, L.close[0]>;
    <F[1].close, L.close[1]>;
    <F[2].close, L.close[2]>;
    <F[3].close, L.close[3]>;
    <open[0], F[0].open, L.open>;
    <open[1], F[1].open, L.open>;
    <open[2], F[2].open, L.open>;
    <open[3], F[3].open, L.open>;
    <down, L.down>;
    <up, L.up>;
edon

node BuildingV1
  sub
    F : Floor[nbFloors];
    L : Lift;
  flow
    request : bool[nbFloors];
    requestDown, requestUp : bool;
  assert
    request[0] = (F[0].B.lightOn | L.B[0].lightOn);
    request[1] = (F[1].B.lightOn | L.B[1].lightOn);
    request[2] = (F[2].B.lightOn | L.B[2].lightOn);
    request[3] = (F[3].B.lightOn | L.B[3].lightOn);
    requestDown = (
      (request[0] & L.level > 0)
      | (request[1] & L.level > 1)
      | (request[2] & L.level > 2)
    );
    requestUp = (
      (request[3] & L.level < 3)
      | (request[2] & L.level < 2)
      | (request[1] & L.level < 1)
    );
  event open[nbFloors] > {down, up};
  trans
    L.level=0 & request[0] |- open[0] ->;
    L.level=1 & request[1] |- open[1] ->;
    L.level=2 & request[2] |- open[2] ->;
    L.level=3 & request[3] |- open[3] ->;
    requestDown |- down ->;
    requestUp |- up ->;
  sync
    <F[0].close, L.close[0]>;
    <F[1].close, L.close[1]>;
    <F[2].close, L.close[2]>;
    <F[3].close, L.close[3]>;
    <open[0], F[0].open, L.open>;
    <open[1], F[1].open, L.open>;
    <open[2], F[2].open, L.open>;
    <open[3], F[3].open, L.open>;
    <down, L.down>;
    <up, L.up>;
edon

node BuildingV2
  sub
    F : Floor[nbFloors];
    L : Lift;
  flow
    request : bool[nbFloors];
    requestDown, requestUp : bool;
  state lastMoveIsUp : bool;
  init lastMoveIsUp := false;
  assert
    request[0] = (F[0].B.lightOn | L.B[0].lightOn);
    request[1] = (F[1].B.lightOn | L.B[1].lightOn);
    request[2] = (F[2].B.lightOn | L.B[2].lightOn);
    request[3] = (F[3].B.lightOn | L.B[3].lightOn);
    requestDown = (
      (request[0] & L.level > 0)
      | (request[1] & L.level > 1)
      | (request[2] & L.level > 2)
    );
    requestUp = (
      (request[3] & L.level < 3)
      | (request[2] & L.level < 2)
      | (request[1] & L.level < 1)
    );
  event open[nbFloors] > {down, up};
  trans
    L.level=0 & request[0] |- open[0] ->;
    L.level=1 & request[1] |- open[1] ->;
    L.level=2 & request[2] |- open[2] ->;
    L.level=3 & request[3] |- open[3] ->;
    ~lastMoveIsUp & requestDown |- down -> lastMoveIsUp := false;
    lastMoveIsUp & requestDown & ~requestUp |- down -> lastMoveIsUp := false;
    lastMoveIsUp & requestUp |- up -> lastMoveIsUp := true;
    ~lastMoveIsUp & requestUp & ~requestDown |- up -> lastMoveIsUp := true;
  sync
    <F[0].close, L.close[0]>;
    <F[1].close, L.close[1]>;
    <F[2].close, L.close[2]>;
    <F[3].close, L.close[3]>;
    <open[0], F[0].open, L.open>;
    <open[1], F[1].open, L.open>;
    <open[2], F[2].open, L.open>;
    <open[3], F[3].open, L.open>;
    <down, L.down>;
    <up, L.up>;
edon