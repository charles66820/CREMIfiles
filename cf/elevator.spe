with Building do
  dead := any_s - src(any_t - self_epsilon);
  notResettable := any_s - coreach(initial, any_t);
  /*
   * SAFETY PROPERTIES P
   * Ecrire P : si "A" alors "B"
   * Calcul au choix de :
   *   notP := A & notB
   *   notP := A - B
   *   notP := notA - notB
   */
  /*
   * P1 : "When a button is push, it lights."
   * P1 : si "a button is push" alors "it lights"
   */

  // example 1
  // simplify :
  //A1 := label F[0].B.push;
  //B1 := [F[0].B.lightOn];
  //notP1 := tgt(A1) - B1;
  // by :
  //notP1 := tgt(label F[0].B.push) - [F[0].B.lightOn];

  // final
  notP1 := (tgt(label F[0].B.push) - [F[0].B.lightOn]) |
           (tgt(label F[1].B.push) - [F[1].B.lightOn]) |
           (tgt(label F[2].B.push) - [F[2].B.lightOn]) |
           (tgt(label F[3].B.push) - [F[3].B.lightOn]) |
           (tgt(label L.B[0].push) - [L.B[0].lightOn]) |
           (tgt(label L.B[1].push) - [L.B[1].lightOn]) |
           (tgt(label L.B[2].push) - [L.B[2].lightOn]) |
           (tgt(label L.B[3].push) - [L.B[3].lightOn]);

  /*
   * P2 : "When the corresponding serice is done, it lights off."
   * P2 : si "a service is done" alors "the corresponding buttons light off"
   */
  notP2 := any_s & (
            (tgt(label F[0].D.close) & [request[0]]) |
            (tgt(label F[1].D.close) & [request[1]]) |
            (tgt(label F[2].D.close) & [request[2]]) |
            (tgt(label F[3].D.close) & [request[3]])
           );
  /*
   * P3 : "At each floor, the door is close if the lift is not here."
   * P3 : si "the lift is not at level i" alors "the door at floor i is close"
   */
  notP3 := any_s & (
             ([L.level!=0] - [F[0].D.isClose]) |
             ([L.level!=1] - [F[1].D.isClose]) |
             ([L.level!=2] - [F[2].D.isClose]) |
             ([L.level!=3] - [F[3].D.isClose])
           );
done

