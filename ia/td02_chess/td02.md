# TD 02

J'ai fait le td avec jupyter notebook. Vous pouvez regarder seulement le fichier `td-chess.ipynb` ou ce pdf et le fichier `main-chess.py`.

## Partie 1

Facture de branchement c'est le nombre max d'enfant.

On a nos plateau au niveau de feuille de la partie (des plateaux final)

1. Le facteur de branchement du jeu représenté sur l’arbre ci-dessus est de `3`. Non toutes les branches d’un arbre de jeu ne doivent pas être de la même hauteur, car des parties peuvent se finir plus vite que d'autres.

2. Le meilleur plateau pour Ami est le `8` et le meilleur pour Ennemi, c'est le `-4`. Un nœud de l'arbre peut avoir qu'un seul fils, car il y as qu'un seul coup possible (par exemple quand le roi est en échec). C'est une mauvaise chose pour amis, car il ne peut pas choisir son coup.

3. La plus grande valeur possible de la feuille "??" qui permet d'élaguer est `3`.

4.![treeAlphaBeta.png](treeAlphaBeta.png)

5.![treeAlphaBeta.png](treeAlphaBetaCutMoreBranch.png)

## Partie 2

1. En moins de 30 seconds on peut aller a une profondeur de `4`. On s'arrête a la 5ème.

| Profondeur :       | 1  |  2  |  3   |   4    |
|:------------------:|:--:|:---:|:----:|:------:|
| Nombre de noeuds : | 21 | 421 | 9323 | 206604 |

2. Codé

3. Codé

4. Matches fait

## Partie 3

1. J'ai codé l'`Iterative Deepening` (`alphaBetaID()`) avant de faire la comparaison.
Avec une partie partie sans aucun coup jouer :

MiniMax :
| Depth | Nb nodes | Move | Time |
|:-----:|:--------:|:----:|:----:|
| 0     | 21 | b1a3 | 0.00|
| 1     | 421 | d2d4 | 0.05|
| 2     | 9323 | c2c4 | 0.73|
| 3     | 206604 | h2h4 | 17.34|

Alpha-beta :
| Depth | Nb nodes | Move | Time |
|:-----:|:--------:|:----:|:----:|
| 0     | 22 | h2h4 | 0.00 |
| 1     | 60 | f3h4 | 0.00 |
| 2     | 905 | f3e5 | 0.07 |
| 3     | 2148 | f3e5 | 0.14 |

Avec une partie partie avec des coups jouer

MiniMax :
| Depth | Nb nodes | Move | Time |
|:-----:|:--------:|:----:|:----:|
| 0     | 45 | d4c5 | 0.01 |
| 1     | 1134 | b2b4 | 0.09 |
| 2     | 44167 | c2c3 | 3.30 |

Alpha-beta :
| Depth | Nb nodes | Move | Time |
|:-----:|:--------:|:----:|:----:|
| 0     | 28 | g7g6 | 0.00 |
| 1     | 803 | c5d4 | 0.07 |
| 2     | 2338 | d7d5 | 0.15 |
| 3     | 51761 | f6g8 | 3.71 |

On voit que pour uns profondeur de `0` et `1` il y a peu de différence de nœuds explorés.
Par contre pour une profondeur plus grand, on voit que `alpha-beta` parcoure beaucoup moins de nœuds.
Et `alpha-beta` et nettement plus rapide.
Sur une partie déjà commencée, on peut voir que `alpha-beta` est bien plus efficace que `miniMax`.

2. Test de `alphaBetaID` (`Iterative Deepening`) qui garantir que la recherche ne dépassera jamais 10s de calcul :

| Depth | Nb nodes | Move | Time |
|:-----:|:--------:|:----:|:----:|
| 0     | 21 | d2d4 | 0.00 |
| 1     | 60 | b1a3 | 0.01 |
| 2     | 883 | g1f3 | 0.20 |
| 3     | 2126 | g1f3 | 0.17 |
| 4     | 44899 | b2b4 | 3.56 |
| 5     | 97920 | h2h3 | 6.29 |

3. Codé
